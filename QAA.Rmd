---
title: "RNA-seq Quality Assessment Assignment (QAA)"
author: "Christina Zakarian"
date: "9-4-2021"
output: html_document
---
### Objectives
The objectives of this assignment are to use existing tools for quality assessment and adaptor trimming, compare the quality assessments to those from own software, and to summarize other important information about the RNA-Seq data set.

### Input Files
The two samples I will be working with and their file locations:   

**1. 10_2G_both_S8_L008**  
  /projects/bgmp/shared/2017_sequencing/demultiplexed/10_2G_both_S8_L008_R1_001.fastq.gz 
  /projects/bgmp/shared/2017_sequencing/demultiplexed/10_2G_both_S8_L008_R2_001.fastq.gz 
  
**2. 31_4F_fox_S22_L008**  
  /projects/bgmp/shared/2017_sequencing/demultiplexed/31_4F_fox_S22_L008_R1_001.fastq.gz
  /projects/bgmp/shared/2017_sequencing/demultiplexed/31_4F_fox_S22_L008_R2_001.fastq.gz
  
## Part 1 – Read quality score distributions

#### 1. FastQC generated plots of quality score distributions and N content distributions

```{r echo=FALSE}
s10_R1_per_base_qual = "fastQC_output/10_2G_both_S8_L008_R1_001_fastqc/Images/per_base_quality.png"
s10_R1_per_seq_qual = "fastQC_output/10_2G_both_S8_L008_R1_001_fastqc/Images/per_sequence_quality.png"
s10_R1_per_base_n = "fastQC_output/10_2G_both_S8_L008_R1_001_fastqc/Images/per_base_n_content.png"
s10_R2_per_base_qual = "fastQC_output/10_2G_both_S8_L008_R2_001_fastqc/Images/per_base_quality.png"
s10_R2_per_seq_qual = "fastQC_output/10_2G_both_S8_L008_R2_001_fastqc/Images/per_sequence_quality.png"
s10_R2_per_base_n = "fastQC_output/10_2G_both_S8_L008_R2_001_fastqc/Images/per_base_n_content.png"

s31_R1_per_base_qual = "fastQC_output/31_4F_fox_S22_L008_R1_001_fastqc/Images/per_base_quality.png"
s31_R1_per_seq_qual = "fastQC_output/31_4F_fox_S22_L008_R1_001_fastqc/Images/per_sequence_quality.png"
s31_R1_per_base_n = "fastQC_output/31_4F_fox_S22_L008_R1_001_fastqc/Images/per_base_n_content.png"
s31_R2_per_base_qual = "fastQC_output/31_4F_fox_S22_L008_R2_001_fastqc/Images/per_base_quality.png"
s31_R2_per_seq_qual = "fastQC_output/31_4F_fox_S22_L008_R2_001_fastqc/Images/per_sequence_quality.png"
s31_R2_per_base_n = "fastQC_output/31_4F_fox_S22_L008_R2_001_fastqc/Images/per_base_n_content.png"
```

#### **Sample #1 (10_2G_both_S8)**

```{r, echo=FALSE,out.width="50%",fig.cap="***Per Sequence Quality Scores.** Distribution of average quality scores per sequence for read 1 (left) and read 2 (right).* ",fig.show='hold'}
knitr::include_graphics(c(s10_R1_per_seq_qual, s10_R2_per_seq_qual))
```

```{r, echo=FALSE,out.width="50%",fig.cap="***Per Base Sequence Quality.** Distribution of average quality scores per base position for read 1 (left) and read 2 (right).*",fig.show='hold'}
knitr::include_graphics(c(s10_R1_per_base_qual, s10_R2_per_base_qual))
```

```{r, echo=FALSE,out.width="50%",fig.cap="***Per Base N Content.** Distribution of average percent N content per base position for read 1 (left) and read 2 (right).* ",fig.show='hold'}
knitr::include_graphics(c(s10_R1_per_base_n, s10_R2_per_base_n))
```

#### **Sample #2 (31_4F_fox_S22)**
```{r, echo=FALSE,out.width="50%",fig.cap="***Per Sequence Quality Scores.** Distribution of average quality scores per sequence for read 1 (left) and read 2 (right).* ",fig.show='hold'}
knitr::include_graphics(c(s31_R1_per_seq_qual, s31_R2_per_seq_qual))
```

```{r, echo=FALSE,out.width="50%",fig.cap="***Per Base Sequence Quality.** Distribution of average quality scores per base position for read 1 (left) and read 2 (right).*",fig.show='hold'}
knitr::include_graphics(c(s31_R1_per_base_qual, s31_R2_per_base_qual))
```

```{r, echo=FALSE,out.width="50%",fig.cap="***Per Base N Content.** Distribution of average percent N content per base position for read 1 (left) and read 2 (right).*",fig.show='hold'}
knitr::include_graphics(c(s31_R1_per_base_n, s31_R2_per_base_n))
```

#### The quality score distribution plots show ... The per base N content plots show ... Are they consistent?


SBATCH script used to generate plots is shown below and can be found under ./sbatch_scripts/fastQC.sh  
```
#!/bin/bash

#SBATCH --account=bgmp
#SBATCH --partition=bgmp
#SBATCH --cpus-per-task=8
#SBATCH --nodes=1
#SBATCH --time=0-04:00:00

# input files
file1="/projects/bgmp/shared/2017_sequencing/demultiplexed/10_2G_both_S8_L008_R1_001.fastq.gz"
file2="/projects/bgmp/shared/2017_sequencing/demultiplexed/10_2G_both_S8_L008_R2_001.fastq.gz"
file3="/projects/bgmp/shared/2017_sequencing/demultiplexed/31_4F_fox_S22_L008_R1_001.fastq.gz"
file4="/projects/bgmp/shared/2017_sequencing/demultiplexed/31_4F_fox_S22_L008_R2_001.fastq.gz"

# output dir
d="/projects/bgmp/czakari2/bioinformatics/Bi623/ass/QAA/fastQC_output"

mkdir $d

conda activate bgmp_py39
module load fastqc/0.11.5

/usr/bin/time -v fastqc $file1 $file2 $file3 $file4 -o $d
```

#### 2. Run your quality score plotting script from your Demultiplexing assignment from Bi622. Describe how the FastQC quality score distribution plots compare to your own. If different, propose an explanation. Also, does the runtime differ? If so, why?

~/bioinformatics/Bi623/ass/QAA/my_QC_output

Where is my quality score plotting script?
    /projects/bgmp/czakari2/bioinformatics/Bi622/Demultiplex/Assignment-the-first/qs_dist.py

Ran as SBATCH script (my_qc.sh)
    ~First file (10_2G_both_S8_L008_R1) finished running in ~34 min
        timewise seems to be okay 
            for me 325908276 lines took ~34 min
            for sally 28905720 lines took ~2min
    ~31_4F_fox_S22_L008_R1 line number:
        15153372 (should be a lot quicker)

### 3. Comment on the overall data quality of your two libraries.

## Part 2 – Adaptor trimming comparison

### 4. Create a new conda environment called QAA and install cutadapt and Trimmomatic. 

Creating a new conda environment:
    conda create --name QAA python=3.9
    conda activate QAA

environment location:               
/projects/bgmp/czakari2/miniconda3/envs/QAA/projects/bgmp/czakari2/miniconda3/envs/QAA
    
conda install cutadapt
conda install trimmomatic
  
cutadapt --version
  3.4
trimmomatic -version
  0.39

### 5. Using cutadapt, properly trim adapter sequences from your assigned files. 

Adaptor sequences (found at https://support-docs.illumina.com/SHARE/AdapterSeq/Content/SHARE/AdapterSeq/TruSeq/UDIndexes.htm):
    Read 1 - AGATCGGAAGAGCACACGTCTGAACTCCAGTCA  
    Read 2 - AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT

Ran as SBATCH script (cutadapt.sh)
    Output in slurm-16182128.out
        10_2G:
            Percent of CPU this job got: 717%
            Elapsed (wall clock) time (h:mm:ss or m:ss): 7:27.15
            Maximum resident set size (kbytes): 921424
            Exit status: 0
        31_4F:
            Percent of CPU this job got: 698%
            Elapsed (wall clock) time (h:mm:ss or m:ss): 0:22.07
            Maximum resident set size (kbytes): 578072
            Exit status: 0

What proportion of reads (both forward and reverse) were trimmed?   

Use your Unix skills to search for the adapter sequences in your datasets and confirm the expected sequence orientations. Report the commands you used, the reasoning behind them, and how you confirmed the adapter sequences. 

### 6. Use Trimmomatic to quality trim your reads. Specify the following, in this order:
    LEADING: quality of 3
    TRAILING: quality of 3
    SLIDING WINDOW: window size of 5 and required quality of 15
    MINLENGTH: 35 bases

Be sure to output compressed files and clear out any intermediate files.
    remove the intermediate adaptor trimmed files -> left with trimmomatic kept and tossed files 

How to use trimmomatic? 
    Read: https://datacarpentry.org/wrangling-genomics/03-trimming/index.html
    trimmomatic PE -threads 8 inpr1 inpr2 out1kept out1toss out2kept out2toss \
        LEADING:3 \
        TRAILING:3 \
        SLIDINGWINDOW:5:15 \
        MINLEN:35

Ran as SBATCH script (trimmomatic.sh)
    Output in slurm-16182913.out:
        31_4F:
            Percent of CPU this job got: 227%
            Elapsed (wall clock) time (h:mm:ss or m:ss): 1:34.84
            Maximum resident set size (kbytes): 437824
            Exit status: 0
        10_2G:
            Percent of CPU this job got: 224%
	        Elapsed (wall clock) time (h:mm:ss or m:ss): 35:51.41
	        Maximum resident set size (kbytes): 439676
            Exit status: 0

Trimmomatic Results:
    31_4F:
        Input Read Pairs: 3788343 
        Both Surviving: 3597908 (94.97%) 
        Forward Only Surviving: 151048 (3.99%) 
        Reverse Only Surviving: 2965 (0.08%) 
        Dropped: 36422 (0.96%)
    10_2G:
        Input Read Pairs: 81477069 
        Both Surviving: 77520904 (95.14%) 
        Forward Only Surviving: 3865386 (4.74%) 
        Reverse Only Surviving: 53289 (0.07%) 
        Dropped: 37490 (0.05%)

zcat 31_4F_fox_S22_L008_R1_001_AT_Trk.fastq.gz | wc -l 
14391632
zcat 31_4F_fox_S22_L008_R1_001_AT_Tro.fastq.gz | wc -l 
604192
zcat 31_4F_fox_S22_L008_R2_001_AT_Trk.fastq.gz | wc -l 
14391632
zcat 31_4F_fox_S22_L008_R2_001_AT_Tro.fastq.gz | wc -l 
11860

### 7. Plot the trimmed read length distributions for both R1 and R2 reads (on the same plot). You can produce 2 different plots for your 2 different RNA-seq samples. There are a number of ways you could possibly do this. One useful thing your plot should show, for example, is whether R1s are trimmed more extensively than R2s, or vice versa. Comment on whether you expect R1s and R2s to be adapter-trimmed at different rates.

How to get distribution values from the trimmed fastq files? 
    use bash to get length distribution and plot with R

Command to get length distribution (did for each of the 4 files):
    zcat 10_2G_both_S8_L008_R2_001_AT_Trk.fastq.gz | sed -n 2~4p | awk '{print length($0)}' > line_counts/10_2G_both_S8_L008_R2_001_AT_Trk.txt

## Part 3 – Alignment and strand-specificity

### 8. Install sofware. In your QAA environment, use conda to install:
    star
    numpy
    pysam
    matplotlib
    Then pip install HTSeq

conda install star
conda install numpy
conda install pysam
conda install matplotlib
pip install HTSeq

### 9. Find publicly available mouse genome fasta files (Ensemble release 104) and generate an alignment database from them. Align the reads to your mouse genomic database using a splice-aware aligner. Use the settings specified in PS8 from Bi621. Hint - you will need to use gene models to perform splice-aware alignment, see PS8 from Bi621.

Downloaded the following fasta and gtf files from ensembl for mouse:
    http://ftp.ensembl.org/pub/release-104/fasta/mus_musculus/dna/Mus_musculus.GRCm39.dna.primary_assembly.fa.gz
    http://ftp.ensembl.org/pub/release-104/gtf/mus_musculus/Mus_musculus.GRCm39.104.gtf.gz

According to what we did in PS8 (but with zebrafish), we need to build a reference database using the downloaded genome fasta files and then we will align our RNA-seq fastq files to the reference database -> this will give us as output a sam file for each of our 2 alignments.

Make a directory to contain the STAR database. 
    Name of assembly: Mus_musculus.GRCm39.dna
    Release of Ensembl: ens104
    Version of STAR: 2.7.9a
    $ mkdir Mus_musculus.GRCm39.dna.ens104.STAR_2.7.9a

Build a STAR database using the mouse reference sequence
    Ran an SBATCH script (buildSTAR.sh) // make sure the files from ensembl are unzipped 
        Percent of CPU this job got: 531%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 17:46.53
        Maximum resident set size (kbytes): 32290796
        Exit status: 0
        
Perform alignment of the trimmed RNAseq files to the STAR database 
    Ran SBATCH scripts // one per read-pair 
        alignSTAR_10_2G.sh 
            slurm-16183731.out 
                Percent of CPU this job got: 738%
                Elapsed (wall clock) time (h:mm:ss or m:ss): 9:46.84
                Maximum resident set size (kbytes): 27522344
                Exit status: 0
        alignSTAR_31_4F.sh 
            slurm-16183733.out 
                Percent of CPU this job got: 558%
                Elapsed (wall clock) time (h:mm:ss or m:ss): 0:40.86
                Maximum resident set size (kbytes): 27346240
                Exit status: 0
    Output files from star alignment in star_10_2G and star_31_4F directories 
    $ wc -l star_10_2G/10_2G_Aligned.out.sam
        162954314          
    $ wc -l star_31_4F/31_4F_Aligned.out.sam 
        7555580 

### 10. Using your script from PS8 in Bi621, report the number of mapped and unmapped reads from each of your 2 sam files. 
    
31_4F_Aligned.out.sam
    Mapped: 6969878
    Unmapped: 225938

10_2G_Aligned.out.sam
    Mapped: 152719556
    Unmapped: 2322252

### 11. Count reads that map to features using htseq-count. You should run htseq-count twice: once with --stranded=yes and again with --stranded=no. Use default parameters otherwise.

Read https://htseq.readthedocs.io/en/release_0.11.1/tour.html#tour

htseq-count --version
    0.13.5

!! Need to direct the output to a file otherwise will just print to standard output stream !!

Ran SBATCH scripts:
    htseq_10_2G.sh (stranded=yes) -> slurm-16183897.out
            Percent of CPU this job got: 99%
            Elapsed (wall clock) time (h:mm:ss or m:ss): 1:36:48
            Maximum resident set size (kbytes): 167724
            Exit status: 0
    htseq_10_2G.sh (stranded=no) -> slurm-16183897.out
            Percent of CPU this job got: 99%
            Elapsed (wall clock) time (h:mm:ss or m:ss): 1:38:05
            Maximum resident set size (kbytes): 170088
            Exit status: 0
    htseq_31_4F.sh (stranded=yes) -> slurm-16183851.out
            Percent of CPU this job got: 99%
            Elapsed (wall clock) time (h:mm:ss or m:ss): 5:25.55
            Maximum resident set size (kbytes): 166672
            Exit status: 0    
    htseq_31_4F.sh (stranded=no) -> slurm-16183851.out  
            Percent of CPU this job got: 100%
            Elapsed (wall clock) time (h:mm:ss or m:ss): 5:37.07
            Maximum resident set size (kbytes): 165764
            Exit status: 0   

### 12. Demonstrate convincingly whether or not the data are from “strand-specific” RNA-Seq libraries. Include any comands/scripts used. Briefly describe your evidence, using quantitative statements (e.g. "I propose that these data are/are not strand-specific, because X% of the reads are y, as opposed to z."). Hint - recall ICA4 from Bi621.

$ awk '{sum+=$2} END {print sum}' 31_4F_stranded.genecount 
$ grep -v '^__' 31_4F_stranded.genecount | awk '{sum+=$2} END {print sum}'
$ grep -v '^__' 31_4F_unstranded.genecount | awk '{sum+=$2} END {print sum}'

Total reads: 3597908
Mapped to feature (stranded=yes): 180499, 5.02%
Mapped to feature (stranded=no): 2922418, 81.2%

what about stranded=reverse?? try running that way? 
$ grep -v '^__' 31_4F_reverse.genecount | awk '{sum+=$2} END {print sum}'
    2913866 -> similar #s to unstranded

$ awk '{sum+=$2} END {print sum}' 10_2G_stranded.genecount
$ grep -v '^__' 10_2G_stranded.genecount | awk '{sum+=$2} END {print sum}'
$ grep -v '^__' 10_2G_unstranded.genecount | awk '{sum+=$2} END {print sum}'

Total reads: 3597908
Mapped to feature (stranded=yes): 180499, 5.02%
Mapped to feature (stranded=no): 2922418, 81.2%


